"use strict";(self.webpackChunkvuepress_theme_knzn=self.webpackChunkvuepress_theme_knzn||[]).push([[5126],{4269:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e=JSON.parse('{"key":"v-361ecdc5","path":"/e5744ce6067ef77674b29b8682e470f0/","title":"14 类型推断，看 TS 有多懂你","lang":"zh-CN","frontmatter":{"permalink":"/e5744ce6067ef77674b29b8682e470f0/","title":"14 类型推断，看 TS 有多懂你","author":"前端程序猿","tags":["typescript"],"categories":["大前端"],"postImage":"/images/typescript.webp"},"excerpt":"<p>在学习基础部分的章节时，我们讲过，在一些定义中如果你没有明确指定类型，编译器会自动推断出适合的类型；比如下面的这个简单例子：</p>\\n","headers":[{"level":2,"title":"1 基本推论","slug":"_1-基本推论","children":[]},{"level":2,"title":"2 多类型联合","slug":"_2-多类型联合","children":[]},{"level":2,"title":"3 上下文类型","slug":"_3-上下文类型","children":[]},{"level":2,"title":"本节小结","slug":"本节小结","children":[]}],"git":{"updatedTime":1659093557000,"contributors":[{"name":"张焕标","email":"1140457303@qq.com","commits":1}]},"filePathRelative":"TypeScript学习笔记/14-type-inference,-see-how-TS-understands-you.md"}')},5886:(n,s,a)=>{a.r(s),a.d(s,{default:()=>o});var e=a(6252);const t=[(0,e.uE)('<p>在学习基础部分的章节时，我们讲过，在一些定义中如果你没有明确指定类型，编译器会自动推断出适合的类型；比如下面的这个简单例子：</p><blockquote><p>构成我们学习最大障碍的是已知的东西，而不是未知的东西。 —— 贝尔纳</p></blockquote><h2 id="_1-基本推论" tabindex="-1"><a class="header-anchor" href="#_1-基本推论" aria-hidden="true">#</a> 1 基本推论</h2><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">&#39;lison&#39;</span>\nname <span class="token operator">=</span> <span class="token number">123</span> <span class="token comment">// error 不能将类型“123”分配给类型“string”</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到，在定义变量 name 的时候我们并没有指定 name 的类型，而是直接给它赋一个字符串。当我们再给 name 赋一个数值的时候，就会报错。在这里，TypeScript 根据我们赋给 name 的值的类型，推断出我们的 name 的类型，这里是 string 类型，当我们再给 string 类型的 name 赋其他类型值的时候就会报错。</p><p>这个是最基本的类型推论，根据右侧的值推断左侧变量的类型，接下来我们看两个更复杂的推论。</p><h2 id="_2-多类型联合" tabindex="-1"><a class="header-anchor" href="#_2-多类型联合" aria-hidden="true">#</a> 2 多类型联合</h2><p>当我们定义一个数组或元组这种包含多个元素的值的时候，多个元素可以有不同的类型，这种时候 TypeScript 会将多个类型合并起来，组成一个联合类型，来看例子：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">]</span>\narr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span> <span class="token comment">// error 不能将类型“false”分配给类型“string | number”</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，此时的 arr 的元素被推断为 string | number，也就是元素可以是 string 类型也可以是 number 类型，除此两种类型外的类型是不可以的。再来看个例子：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">let</span> value <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">?</span> <span class="token string">&#39;abc&#39;</span> <span class="token operator">:</span> <span class="token number">123</span>\nvalue <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// error 不能将类型“false”分配给类型“string | number”</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们给 value 赋值为一个三元操作符表达式，Math.random() * 10 的值为 0-10 的随机数。这里判断，如果这个随机值大于 5，则赋给 value 的值为字符串’abc’，否则为数值 123，所以最后编译器推断出的类型为联合类型 string | number，当给它再赋值为 false 的时候就会报错。</p><h2 id="_3-上下文类型" tabindex="-1"><a class="header-anchor" href="#_3-上下文类型" aria-hidden="true">#</a> 3 上下文类型</h2><p>我们上面讲的两个例子都是根据=符号右边值的类型，推断左侧值的类型。现在要讲的上下文类型则相反，它是根据左侧的类型推断右侧的一些类型，先来看例子：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onmousedown</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">mouseEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mouseEvent<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// error 类型“MouseEvent”上不存在属性“a”</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，表达式左侧是 window.onmousedown(鼠标按下时发生事件)，因此 TypeScript 会推断赋值表达式右侧函数的参数是事件对象，因为左侧是 mousedown 事件，所以 TypeScript 推断 mouseEvent 的类型是 MouseEvent。在回调函数中使用 mouseEvent 的时候，你可以访问鼠标事件对象的所有属性和方法，当访问不存在属性的时候，就会报错</p><p>以上便是我要讲的三种常见的类型推论。在我们日常开发中，必写的类型还是要明确指定的，这样我们才能更准确地得到类型信息和开发辅助。</p><h2 id="本节小结" tabindex="-1"><a class="header-anchor" href="#本节小结" aria-hidden="true">#</a> 本节小结</h2><p>本小节我们学习了 TypeScript 编译器进行类型推断的论据，其中有两种是由右推左的，也就是在赋值时根据右侧要赋的具体值，推断左侧要赋值的目标的类型，包括基本推论和多类型联合推论。基础推论是最基础的推论，多类型联合推论是根据数组、代码逻辑等，推断出多个符合的类型，然后组成联合类型的推论。还有一种由左推右的推论，我们是通过给元素绑定事件来讲解的，根据左侧要赋值的目标，来推断出右侧要赋的值中的一些类型信息。</p><p>下个小节我们将学习类型兼容性，我们知道 JavaScript 是灵活的，所以 TypeScript 通过类型兼容性来满足它的灵活特点，下个小节我们将介绍多种情况的兼容性表现。</p>',20)],p={},o=(0,a(3744).Z)(p,[["render",function(n,s){return(0,e.wg)(),(0,e.iD)("div",null,t)}]])}}]);