"use strict";(self.webpackChunkvuepress_theme_knzn=self.webpackChunkvuepress_theme_knzn||[]).push([[6240],{7066:(s,n,e)=>{e.r(n),e.d(n,{data:()=>a});const a=JSON.parse('{"key":"v-4c6c05e0","path":"/e843ac3be0ab024f5f660dd7d04b1b22/","title":"26 使用模块封装代码","lang":"zh-CN","frontmatter":{"permalink":"/e843ac3be0ab024f5f660dd7d04b1b22/","title":"26 使用模块封装代码","author":"前端程序猿","tags":["typescript"],"categories":["大前端"],"postImage":"/images/typescript.webp"},"excerpt":"<p>TypeScript 在 1.5 版本之前，有内部模块和外部模块的概念，从 1.5 版本开始，内部模块改称作命名空间（我们下个小节会讲），外部模块改称为模块。如果你对模块的知识一无所知，建议你先重点学习一下 CommonJS 模块系统和 ES6 模块系统，TypeScript 中的模块系统是遵循 ES6 标准的，所以你需要重点学习 ES6 标准中的模块知识，这里推荐大家几个链接，大家可以在这里去学习一下：</p>\\n","headers":[{"level":2,"title":"1. export","slug":"_1-export","children":[]},{"level":2,"title":"2. import","slug":"_2-import","children":[]},{"level":2,"title":"3. export default","slug":"_3-export-default","children":[]},{"level":2,"title":"4. export = 和 import = require()","slug":"_4-export-和-import-require","children":[]},{"level":2,"title":"5. 相对和非相对模块导入","slug":"_5-相对和非相对模块导入","children":[]},{"level":2,"title":"小结","slug":"小结","children":[]}],"git":{"updatedTime":1659093557000,"contributors":[{"name":"张焕标","email":"1140457303@qq.com","commits":1}]},"filePathRelative":"TypeScript学习笔记/26-Encapsulating-code-with-modules.md"}')},3255:(s,n,e)=>{e.r(n),e.d(n,{default:()=>u});var a=e(6252);const t=(0,a._)("p",null,"TypeScript 在 1.5 版本之前，有内部模块和外部模块的概念，从 1.5 版本开始，内部模块改称作命名空间（我们下个小节会讲），外部模块改称为模块。如果你对模块的知识一无所知，建议你先重点学习一下 CommonJS 模块系统和 ES6 模块系统，TypeScript 中的模块系统是遵循 ES6 标准的，所以你需要重点学习 ES6 标准中的模块知识，这里推荐大家几个链接，大家可以在这里去学习一下：",-1),p=(0,a._)("blockquote",null,[(0,a._)("p",null,"横眉冷对千夫指，俯首甘为孺子牛 ——鲁迅")],-1),o={href:"http://www.mamicode.com/info-detail-1935796.html",target:"_blank",rel:"noopener noreferrer"},i=(0,a.Uk)("CommonJS/AMD/CMD/ES6 规范"),l={href:"http://es6.ruanyifeng.com/#docs/module",target:"_blank",rel:"noopener noreferrer"},r=(0,a.Uk)("ECMAScript6 入门 - Module 的语法"),c=(0,a.uE)('<p>TypeScript 和 ES6 保持一致，包含顶级 import 或 export 的文件都被当成一个模块，则里面定义的内容仅模块内可见，而不是全局可见。TypeScript 的模块除了遵循 ES6 标准的模块语法外，还有一些特定语法，用于类型系统兼容多个模块格式，下面我们来开始学习 TypeScript 模块。</p><h2 id="_1-export" tabindex="-1"><a class="header-anchor" href="#_1-export" aria-hidden="true">#</a> 1. export</h2><p>TypeScript 中，仍然使用 export 来导出声明，而且能够导出的不仅有变量、函数、类，还包括 TypeScript 特有的类型别名和接口。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// funcInterface.ts</span>\n<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Func</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">B</span> <span class="token punctuation">}</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">B</span> <span class="token keyword">as</span> ClassB <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，你可以使用 export 直接导出一个声明，也可以先声明一个类或者其它内容，然后使用 export {}的形式导出，也可以使用 as 来为导出的接口换个名字再导出一次。</p><p>你也可以像 ES6 模块那样重新导出一个模块，也就是 export 一个引入内容，也可以重新导出部分内容，也可以重命名重新导出：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// main.ts</span>\n<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">&#39;./moduleB&#39;</span>\n<span class="token comment">// main.ts</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./moduleB&#39;</span>\n<span class="token comment">// main.ts</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> name <span class="token keyword">as</span> nameProp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./moduleB&#39;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-import" tabindex="-1"><a class="header-anchor" href="#_2-import" aria-hidden="true">#</a> 2. import</h2><p>接下来我们来看导出的模块怎么引入，依然是使用 import：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// main.ts</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./moduleB&#39;</span>\n<span class="token comment">// main.ts</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> info <span class="token keyword">from</span> <span class="token string">&#39;./moduleB&#39;</span>\n<span class="token comment">//main.ts</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> name <span class="token keyword">as</span> nameProp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./moduleB&#39;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样，可以使用 import 直接接模块名或文件路径，进行具有副作用的导入：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token string">&#39;./set-title.ts&#39;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_3-export-default" tabindex="-1"><a class="header-anchor" href="#_3-export-default" aria-hidden="true">#</a> 3. export default</h2><p>同样在 TypeScript 中使用 export default 默认导出，这个和 ES6 一样：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// moduleB.ts</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">&#39;lison&#39;</span>\n<span class="token comment">// main.ts</span>\n<span class="token keyword">import</span> name <span class="token keyword">from</span> <span class="token string">&#39;./moduleB.ts&#39;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// &#39;lison&#39;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-export-和-import-require" tabindex="-1"><a class="header-anchor" href="#_4-export-和-import-require" aria-hidden="true">#</a> 4. export = 和 import = require()</h2><p>TypeScript 可以将代码编译为 CommonJS、AMD 或其它模块系统代码，同时会生成对应的声明文件。我们知道 CommonJS 和 AMD 两种模块系统语法是不兼容的，所以 TypeScript 为了兼容这两种语法，使得我们编译后的声明文件同时支持这两种模块系统，增加了 export =和 import xx = require()两个语句</p><p>当我们想要导出一个模块时，可以使用 export =来导出：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// moduleC.ts</span>\n<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">export</span> <span class="token operator">=</span> <span class="token constant">C</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后使用这个形式导出的模块，必须使用 import xx = require()来引入：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// main.ts</span>\n<span class="token keyword">import</span> ClassC <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;./moduleC&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你的模块不需要同时支持这两种模块系统，可以不使用 export =来导出内容。</p><h2 id="_5-相对和非相对模块导入" tabindex="-1"><a class="header-anchor" href="#_5-相对和非相对模块导入" aria-hidden="true">#</a> 5. 相对和非相对模块导入</h2><p>根据引入模块的路径是相对还是非相对，模块的导入会以不同的方式解析：</p><p>相对导入是以./或…/开头的，./表示当前目录，而…/表示当前目录的上一级目录。以下面的文件目录为例：</p><div class="language-txt ext-txt line-numbers-mode"><pre class="language-txt"><code>src\n ╠═ module\n ║    ╠═ moduleA.ts\n ║    ╚═ moduleB.ts\n ╚═ core\n      ╚═ index.ts\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上面的文件目录为例，我们如果在 index.ts 中引入两个模块，和在 moduleA 模块中引入 moduleB 是这样的：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// moduleA.ts</span>\n<span class="token keyword">import</span> moduleB <span class="token keyword">from</span> <span class="token string">&#39;./moduleB.ts&#39;</span> <span class="token comment">// 这里在moduleA.ts文件里引入同级的moduleB.ts文件，所以使用./表示moduleA.ts文件当前所在路径</span>\n<span class="token comment">// index.ts</span>\n<span class="token keyword">import</span> moduleA <span class="token keyword">from</span> <span class="token string">&#39;../module/moduleA.ts&#39;</span>\n<span class="token keyword">import</span> moduleB <span class="token keyword">from</span> <span class="token string">&#39;../module/moduleB&#39;</span> <span class="token comment">// 这里省略了.ts后缀也可以</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们引用模块文件的时候省略了 .ts 后缀也是可以的，这就涉及到一个模块解析策略。我们以上面例子中这个 moduleB 为例，编译器在解析模块引用的时候，如果遇到省略后缀的情况，会依次查找以该名称为文件名的.ts、.tsx、.d.ts 文件；如果没找到，会在当前文件夹下的 package.json 文件里查找 types 字段指定的模块路径，然后通过这个路径去查找模块；如果没找到 package.json 文件或者 types 字段，则会将 moduleB 当做文件夹去查找，如果它确实是文件夹，将会在这个文件夹下依次查找 index.ts、index.tsx、index.d.ts。 如果还没找到，会在上面例子中 module 文件夹的上级文件夹继续查找，查找规则和前面这些顺序一致。</p><p>除了这两种符号开头的路径，都被当做非相对路径。非相对模块的导入可以相对于 baseUrl，也可以通过路径映射，还可以解析为外部模块。关于模块解析的更多配置，我们会在后面章节介绍，这里我们主要学习语法。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本小节我们学习了 TypeScript 的模块系统，使用模块我们可以将一些逻辑封装在模块中，方便在多个文件中引入使用，这样可以帮我们更方便地整理、复用代码。在这个小节中我们学习了 TypeScript 中遵循 ES6 的模块语句，其中导出语句为 export，引入语句为 import，如果要默认导出，则使用 export default。我们还学习了 TypeScript 中特别增加的兼容 CommonJS 和 AMD 模块系统的导出和导入语句：export =和 import xx = require()。最后我们简单学习了相对模块和非相对模块的引入，同时还介绍了模块引用的解析策略。</p><p>下个小节我们将学习命名空间，命名空间在 TypeScirpt1.5 版本之前称为“内部模块”，它可以将属于一类的代码进行汇总封装，效果类似于我们这节课学习的模块，下个小节我们来进行学习。</p>',33),d={},u=(0,e(3744).Z)(d,[["render",function(s,n){const e=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)("div",null,[t,p,(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("a",o,[i,(0,a.Wm)(e)])]),(0,a._)("li",null,[(0,a._)("a",l,[r,(0,a.Wm)(e)])])]),c])}]])}}]);